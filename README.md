# Learning Objectives

- Understand the purpose of Services in Angular
- Know how to inject services into controllers
- Know how to call methods on services from in their controllers and put the response on $scope
- Know the difference between factories and services

#What is a service?
[Documentation definition](https://docs.angularjs.org/guide/services)

In a nutshell, services are objects that store information and functionality for us. When we access a service in a controller, we are getting a reference to a restricted instance of that object. This is called a **[singleton](https://en.wikipedia.org/wiki/Singleton_pattern)**. If multiple controllers are referencing one instance of an object, then they can all share and manipulate the same data from that instance.

From the docs:

- **Lazily instantiated** – Angular only instantiates a service when an application component depends on it.
- **Singletons** – Each component dependent on a service gets a reference to the single instance generated by the service factory.

# What do services do?
Services allow us to share code across multiple controllers without using `$rootScope`. This allows us to  keep our controllers "skinny", it also eliminates the need to rewrite a lot of code, which adhears to the DRY principle.

# How do we include them?
## Dependency Injection
**[Dependency Injection](https://docs.angularjs.org/guide/di)** is how a component (e.g., controller, service, etc.) gains access to it's dependencies, when they are needed. We pass the dependencies into the components that require them as functions. There are [three](https://docs.angularjs.org/guide/di#dependency-annotation) different ways of annotating your dependency injections. We use two of them commonly, although one of them is the preferred way and should be used most often.

The functions we’re passing in as dependencies are callback functions and won’t be run until angular wants them to be called.
This is because angular needs to **[bootstrap](https://docs.angularjs.org/guide/bootstrap)**. 

**[Bootstrapping](https://docs.angularjs.org/tutorial/step_00)** means angular is loading all the files, letting controllers, services, and directives, register themselves with a key and then it does a second pass where it can pass in the requested dependencies into each requestor because it knows all the keys and functions to invoke for each request.

# Some built in services
- [$http](https://docs.angularjs.org/api/ng/service/$http)
- [$location](https://docs.angularjs.org/api/ng/service/$location)
- [$log](https://docs.angularjs.org/api/ng/service/$log)
- [$filter](https://docs.angularjs.org/api/ng/filter/filter)

## Demo of [$watch](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$watch)
- Watch allows us to observe model mutation on scope

```
//example of shallow watching
$scope.user = "Jane"
$scope.$watch('user', function() {
  console.log('user has changed!');
});

//example of deep watching (notice the
//third argument, set to true)
$scope.users = [
	{ name: "Billy" },
	{ name: "Sally" },
	{ name: "Jimmy" }
];
$scope.$watch('users', function() {
  console.log('user has changed!');
}, true);
```

There are three depths of $watch, two are seen above, check all three out in depth [here](http://teropa.info/blog/2014/01/26/the-three-watch-depths-of-angularjs.html)

# Create your own service
There are two (main) ways to create a Service: [Factory vs Service](https://www.youtube.com/watch?v=0ybzZ3zZus0)

We’re going to focus on just services for now.

When a service is invoked it is acting just like a constructor function.  It will create a new object, bind the ‘this’ pointer to that object and return that object to the controller that is asking for it.

For simplicity sake don’t return an object in your service. Just use the this pointer/context

Services won’t necessarily trigger UI updates.
A good pattern is to only pull the data when a screen/controller is loaded/executed the first time.  Do not depend on data changes in the service to update your controller/screen.


```
angular.module('MyApp')
.service('UserService', function() {
  var hiddenVariable = "hidden from controller due to lexical scope";
  this.foo = "bar";
  this.fun = function() {
  	return "baz";
  };
  this.createNewUser = function() {
    return {
      company: null,
      role: null,
      username: null,
      email: null
    }
  };
});
```

The service object in our controller can only access the properties on the **this** pointer in the service.

In the example above, the variable "hiddenVariable" is not accessible from a controller. This is referred to as [lexical scope](http://whatis.techtarget.com/definition/lexical-scoping-static-scoping).


## Extra Resources
- [More on filters](https://scotch.io/tutorials/all-about-the-built-in-angularjs-filters)
- [Service as a Factory](https://thinkster.io/angular-rails#angular-services)
- [Factory vs Service vs Provider](http://tylermcginnis.com/angularjs-factory-vs-service-vs-provider/)
- [$More on $log](https://www.youtube.com/watch?v=jEpbjve5iHk)